diff --git a/OpenEXR/IlmImf/ImfDeepTiledOutputFile.cpp b/OpenEXR/IlmImf/ImfDeepTiledOutputFile.cpp
index 33704f0..e3a9b04 100644
--- a/OpenEXR/IlmImf/ImfDeepTiledOutputFile.cpp
+++ b/OpenEXR/IlmImf/ImfDeepTiledOutputFile.cpp
@@ -1227,7 +1227,7 @@ DeepTiledOutputFile::initialize (const Header &header)
                                       _data->numYTiles);
                                       
     //ignore the existing value of chunkCount - correct it if it's wrong
-    _data->header.setChunkCount(getChunkOffsetTableSize(_data->header,true));                                   
+    _data->header.setChunkCount(getChunkOffsetTableSize(_data->header));
                                       
     _data->maxSampleCountTableSize = _data->tileDesc.ySize *
                                      _data->tileDesc.xSize *
diff --git a/OpenEXR/IlmImf/ImfMisc.cpp b/OpenEXR/IlmImf/ImfMisc.cpp
index d0b6fb2..7d69798 100644
--- a/OpenEXR/IlmImf/ImfMisc.cpp
+++ b/OpenEXR/IlmImf/ImfMisc.cpp
@@ -1900,18 +1900,30 @@ int
 getTiledChunkOffsetTableSize(const Header& header);
 
 int
-getChunkOffsetTableSize(const Header& header,bool ignore_attribute)
+getChunkOffsetTableSize(const Header& header,bool)
 {
-    if(!ignore_attribute && header.hasChunkCount())
-    {
-        return header.chunkCount();
-    }
-    
+    //
+    // if there is a type in the header which indicates the part is not a currently supported type,
+    // use the chunkCount attribute
+    //
+
+
     if(header.hasType()  && !isSupportedType(header.type()))
     {
-        throw IEX_NAMESPACE::ArgExc ("unsupported header type to "
-        "get chunk offset table size");
+        if(header.hasChunkCount())
+        {
+           return header.chunkCount();
+        }
+        else
+        {
+           throw IEX_NAMESPACE::ArgExc ("unsupported header type to "
+           "get chunk offset table size");
+        }
     }
+
+    //
+    // part is a known type - ignore the header attribute and compute the chunk size from the header
+    //
     if (isTiled(header.type()) == false)
         return getScanlineChunkOffsetTableSize(header);
     else
diff --git a/OpenEXR/IlmImf/ImfMisc.h b/OpenEXR/IlmImf/ImfMisc.h
index 4cb7607..f1cf648 100644
--- a/OpenEXR/IlmImf/ImfMisc.h
+++ b/OpenEXR/IlmImf/ImfMisc.h
@@ -464,13 +464,16 @@ bool usesLongNames (const Header &header);
 
 
 //
-// compute size of chunk offset table - if ignore_attribute set to true
-// will compute from the image size and layout, rather than the attribute
-// The default behaviour is to read the attribute
+// compute size of chunk offset table - for existing types, computes
+// the chunk size from the image size, compression type, and tile description
+// (for tiled types). If the type is not supported, uses the chunkCount attribute
+// if present, or throws an exception otherwise
+// deprecated_attribute is no longer used by this function
+//
 //
 
 IMF_EXPORT
-int getChunkOffsetTableSize(const Header& header,bool ignore_attribute=false);
+int getChunkOffsetTableSize(const Header& header,bool deprecated_attribute=false);
 
 OPENEXR_IMF_INTERNAL_NAMESPACE_HEADER_EXIT
 
diff --git a/OpenEXR/IlmImf/ImfMultiPartInputFile.cpp b/OpenEXR/IlmImf/ImfMultiPartInputFile.cpp
index c2ffecb..eba675c 100644
--- a/OpenEXR/IlmImf/ImfMultiPartInputFile.cpp
+++ b/OpenEXR/IlmImf/ImfMultiPartInputFile.cpp
@@ -733,7 +733,7 @@ MultiPartInputFile::Data::readChunkOffsetTables(bool reconstructChunkOffsetTable
 
     for (size_t i = 0; i < parts.size(); i++)
     {
-        int chunkOffsetTableSize = getChunkOffsetTableSize(parts[i]->header,false);
+        int chunkOffsetTableSize = getChunkOffsetTableSize(parts[i]->header);
         parts[i]->chunkOffsets.resize(chunkOffsetTableSize);
 
         for (int j = 0; j < chunkOffsetTableSize; j++)
diff --git a/OpenEXR/IlmImf/ImfMultiPartOutputFile.cpp b/OpenEXR/IlmImf/ImfMultiPartOutputFile.cpp
index 27add0c..a4c9331 100644
--- a/OpenEXR/IlmImf/ImfMultiPartOutputFile.cpp
+++ b/OpenEXR/IlmImf/ImfMultiPartOutputFile.cpp
@@ -145,7 +145,7 @@ MultiPartOutputFile::Data::do_header_sanity_checks(bool overrideSharedAttributes
     if (isMultiPart)
     {
         // multipart files must contain a chunkCount attribute
-        _headers[0].setChunkCount(getChunkOffsetTableSize(_headers[0],true));
+        _headers[0].setChunkCount(getChunkOffsetTableSize(_headers[0]));
         
         for (size_t i = 1; i < parts; i++)
         {
@@ -153,7 +153,7 @@ MultiPartOutputFile::Data::do_header_sanity_checks(bool overrideSharedAttributes
                 throw IEX_NAMESPACE::ArgExc ("Every header in a multipart file should have a type");
             
             
-            _headers[i].setChunkCount(getChunkOffsetTableSize(_headers[i],true));
+            _headers[i].setChunkCount(getChunkOffsetTableSize(_headers[i]));
             _headers[i].sanityCheck (_headers[i].hasTileDescription(), isMultiPart);
             
             
@@ -185,7 +185,7 @@ MultiPartOutputFile::Data::do_header_sanity_checks(bool overrideSharedAttributes
         
         if (_headers[0].hasType() && isImage(_headers[0].type()) == false)
         {
-            _headers[0].setChunkCount(getChunkOffsetTableSize(_headers[0],true));
+            _headers[0].setChunkCount(getChunkOffsetTableSize(_headers[0]));
         }
         
     }
@@ -494,7 +494,7 @@ MultiPartOutputFile::Data::writeChunkTableOffsets (vector<OutputPartData*> &part
 {
     for (size_t i = 0; i < parts.size(); i++)
     {
-        int chunkTableSize = getChunkOffsetTableSize(parts[i]->header,false);
+        int chunkTableSize = getChunkOffsetTableSize(parts[i]->header);
 
         Int64 pos = os->tellp();
 
